# MIKSYS

MIKSYS -- это SoC, разработанная для платы [Марсоход2](https://marsohod.org/howtostart/marsohod2) с ПЛИС Altera Cyclone III.
Работа выполнена для получения опыта разработки на verilog. Практической ценности не имеет.
Была поставлена цель выжать из платы производительность, достаточную для отображения 3д графики.

Обсуждение проекта: http://marsohod.org/forum/proekty-polzovatelej/4110-realizatsiya-3d-grafiki-na-plate-marsohod2

![](miksys.png)

-   Архитектура относится к классу SIMD. Исполняющие блоки PU0 - PU3
    одновременно выполняют одну и ту же команду с разными
    наборами данных.
-   Архитектура 16-битная. Размер любого регистра, ячейки кэша, ячейки
    памяти - 16 бит. Команды занимают по 2 ячейки — 32 бита. В блоках
    PU0 - PU3 реализована целочисленная 16-битная арифметика.
-   Отсутствует прямой обмен данными между исполняющими блоками и
    оперативной памятью. Обмен между кэшем и оперативной памятью
    осуществляется явно, командами READ и WRITE. Исполняющие блоки могут
    одновременно обращаться только к группе из 4 последовательных ячеек
    в кэше.
-   Блок PU0 является основным. Только он может использовать порты
    ввода-вывода, менять указатель команд, задавать адрес для обращения
    к кэшу и т.д. Также только блок PU0 может менять общие для всех PU
    регистры R8-R15.
-   С целью увеличения производительности были приняты некоторые
    решения, уменьшающие удобство программирования. Например, есть
    команды переходов, после которых не сбрасывается конвеер команд. Это
    значит, что после перехода еще 4 команды будут выполнены со
    старого места. В конце документа приведен список подобных
    неочевидных особенностей.

# Файлы:

* doc/miksys.md - документация
* prepare_port.sh - скрипт для настройки последовательного порта (linux)
* verilog/* - проект quartus
* qt_sim - эмулятор
* mbftdi - программатор http://marsohod.org/downloads/doc_download/91-programmator-usb-mbftdi-versiya-1-0 (linux)
* miksys_soft/miksys_cc.py - компилятор `C` для miksys, основанный на LCC 4.2
* miksys_soft/miksys_asm.py - транслятор ассемблера
* miksys_soft/pack.py - упаковывает откомпилированную программу для загрузки по последовательному порту
* miksys_soft/pack_usb.py - упаковывает откомпилированную программу для загрузки по USB
* miksys_soft/demo3d - демонстрационная программа с 3д графикой. Режим вращения и перспектива переключаются кнопкой на плате (вторая кнопка - reset). Можно управлять вращением с PS/2 клавиатуры (кнопки WASD) или с PS/2 мыши.
* miksys_soft/mikasm.lang - подсветка синтаксиса ассемблера для gtksourceview
* miksys_soft/ustartup - загрузчик
* miksys_soft/include/std.H - описания и адреса функций, находящихся в загрузчике. При пересборке загрузчика файл обновляется автоматически.


# Введение

Здесь приведена инструкция по сборке для Linux.
Теоретически, в Windows проект также должен собираться, но скрипты сборки потребуется менять.

Путь к quartus/bin (версия 13.1) должен быть добавлен в PATH.
Зависимости для эмулятора: libqt4-dev libqt4-dev-bin qt4-qmake qtcreator.

## Сборка проекта и демонстрационной программы demo3d:

    $ make

## Запуск demo3d в эмуляторе:

    $ make sim_demo3d

Нажать на Start.

Должен появиться крутящийся домик. Крутиться будет медленно и рывками, т.к эмулятор раз в 10 медленнее оригинала. Вращение и перспектива переключается кнопкой на плате. В qt_sim кнопка на плате соответствует чекбоксу "К". Для переключения режима нужно нажать на него, подождать пару секунд (т.к эмулятор работает медленно) и нажать еще раз.

Если автоматическое вращение остановлено, поворотом домика можно управлять с клавиатуры (WASD). В qt_sim перед этим нужно кликнуть на изображение, чтобы фокус ввода перешел куда нужно. Эмуляция мышки в qt_sim на данный момент не реализована.

## Написание программы на ассемблере

Справка по архитектуре и командам находится ниже. Приведенные там примеры программ можно найти в miksys_soft/examples.

Сборка программы some_prog.S выглядит так:

    ./miksys_asm.py some_prog.S some_prog.bin  # компиляция
    ./pack.py some_prog.bin some_prog.packed   # добавление контрольной суммы для загрузки через последомательный порт
    ./pack_usb.py some_prog.bin some_prog.usb_packed   # добавление контрольной суммы для загрузки по USB
    cp some_prog.packed serial_in              # нужно, чтобы запустить some_prog в эмуляторе. Эмулятор загружается из miksys_soft/serial_in

## Написание программы на C

Рекомендуется добавить ссылку на miksys_cc.py в /usr/local/bin:

    $ ln -s `pwd`/miksys_soft/miksys_cc.py /usr/local/bin/miksys_cc

Компиляция демонстрационной программы, выводящей список простых чисел:

    $ cd miksys_soft/examples
    $ miksys_cc primes.c -o primes -pserial

Заголовочные файлы по умолчанию берутся из каталога miksys_soft/include/c

Особенности реализации C в miksys:
* В одном байте 16 бит и sizeof(int) = sizeof(char) = 1
* Доступны только данные, находящиеся в кэше. Загрузка в кэш осуществляется явно (вызовом функции sdram из miksys.h).
* Не поддерживаются указатели на функции (т.к. адресное пространство данных соответствует кэшу, а функции вызываются по адресу в sdram)
* Не поддерживаются функции с переменным числом аргументов

## Запись прошивки в марсоход2:
    $ make write

## Запись прошивки в EPCS4 на плате разъемов к марсоход2:
    $ make write_epcs4

## Загрузка через последовательный порт
Настроить baud_rate виртуального последовательного порта 6MHz (в линуксе делается скриптом prepare_port.sh).
Отправить some_program.packed в последовательный порт.

    $ ./prepare_port.sh
    $ cat miksys_soft/demo3d/demo3d.packed > /dev/serial/by-id/usb-FTDI_Dual_RS232-HS-if01-port0

## Загрузка с флешки

Работает не для всех флешек (я использую флешку SanDisk CruzerBlade - для неё работает).

Откомпилированную программу нужно записать на флешку, начиная с блока 2048 (начало 2-го мегабайта).
Это удобно сделать, если настроить таблицу разделов на флешке, чтобы один из разделов начинался с этого адреса. Например:

    Устр-во Загр     Начало       Конец       Блоки   Id  Система
    /dev/sdb1          264192    15633407     7684608   83  Linux
    /dev/sdb2            2048      264191      131072   83  Linux

В этом случае запись на флешку осуществляется командой `sudo dd if=miksys_soft/demo3d/demo3d.usb_packed of=/dev/sdb2`


Система команд
--------------

Opcode | Name           | Description
------ | ----           | -----------
0x00   | [NOP](#nop)  | Пропуск такта
0x01   | [J](#jcallret)      | Переход по адресу (без сброса конвеера)
0x01   | [CALL](#jcallret)   | Вызов функции (без сброса конвеера)
0x01   | [RET](#jcallret)    | Возврат из функции (также используется для перехода по абсолютному адресу; без сброса конвеера)
0x02   | [CMOV](#cmov) | Запись константы в регистр или спец. регистр
0x03   | [CCMOV](#ccmov) | Запись константы в кэш
0x05   | [DJ](#djdcalldret)    | Переход по адресу со сбросом конвеера
0x05   | [DCALL](#djdcalldret) | Вызов функции со сбросом конвеера
0x05   | [DRET](#djdcalldret)  | Возврат из функции со сбросом конвеера (также используется для перехода по абсолютному адресу)
0x0C   | [SHL](#shlshrmulsmul)  | Битовый сдвиг влево. Результат сохраняется в спец. регистр.
0x0C   | [SHR](#shlshrmulsmul)  | Битовый сдвиг в право. Результат сохраняется в спец. регистр.
0x0D   | [MUL](#shlshrmulsmul)  | Беззнаковое умножение. Результат сохраняется в спец. регистры.
0x0D   | [WMUL](#wmul) | Двойное умножение (32bit x 16bit) с отбрасыванием младших 16bit. Результат сохраняется в спец. регистры.
0x0E   | [SMUL](#shlshrmulsmul) | Умножение со знаком (доступно только в PU0). Результат сохраняется в спец. регистры.
0x0F   | [READ](#readwrite)  | Чтение блока данных из оперативной памяти в кэш
0x0F   | [WRITE](#readwrite) | Запись блока данных из кэша в оперативную память
0x10   | [OR](#arithmetic-commands) | Побитовое ИЛИ
0x11   | [XOR](#arithmetic-commands) | Побитовое исключающее ИЛИ
0x12   | [AND](#arithmetic-commands) | Побитовое И
0x13   | [TST](#cmptst)  | Побитовое И без сохранения результата (меняются толко флаги)
0x14   | [MOV](#mov)  | Копирование значения из регистра в регистр или между регистром и кэшем
0x14   | [IN](#inout)    | Чтение из порта ввода-вывода. Не может быть условным.
0x14   | [OUT](#inout)   | Запись в порт ввода-вывод. Не может быть условным.
0x15   | [LPU0-LPU3] | Загрузка из кэша в конкретный PU (не реализовано)
0x16   | [RGBADD](#arithmetic-commands) | Сложение двух цветов в формате R5G6B5
0x17   | [RGBSHR](#arithmetic-commands) | Сдвиг на 1 бит вправо цвета в формате R5G6B5 (яркость уменьшается в 2 раза). Двухадресная команда.
0x18   | [ADD](#arithmetic-commands) | Сложение
0x19   | [RSB](#arithmetic-commands) | Обратное вычитание (меняется порядок операндов)
0x1A   | [SUB](#arithmetic-commands) | Вычитание
0x1B   | [CMP](#cmptst)  | Сравнение (вычитание без сохранения результата)
0x1C   | [ADС](#arithmetic-commands) | Сложение с учетом переноса в предыдущей команде
0x1D   | [RSС](#arithmetic-commands) | Обратное вычитание с учетом переноса в предыдущей команде
0x1E   | [SBС](#arithmetic-commands) | Вычитание с учетом переноса в предыдущей команде

Регистры
--------

Существует 16 регистров общего назначения R0-R15.\
R0-R7 свои у каждого PU. R8-R15 – общие, но могут меняться только из
PU0. Если все PU выполнят команду "MOV R8, R1", то в R8 окажется
значение R1 из PU0, независимо от R1 в других PU.

### Специальные регистры

У разных PU спец. регистры разные. Некоторые спец. регистры есть только у PU0.

Специальные регистры, доступные для чтения

Номер | Название     | Описание
----- | --------     | --------
0     | IN\_FLAGS    | [Регистр состояния](#регистр-состояния-in-flags)
1     | MEM\_ADDR\_LO | Младшие 16 бит адреса для операции с оперативной памятью или перехода (только в PU0)
2     | MEM\_ADDR\_HI | Старшие 16 бит адреса для операции с оперативной памятью или перехода (только в PU0)
3     | IN\_CLOCK    | Счетчик тактов (только в PU0)
4     | IN\_TIME\_MS4 | Счетчик, увеличивающися 4000 раз в секунду (только в PU0)
5     | MUL\_RESULT\_LO / SHIFT\_RESULT | Результат целочисленного умножения, младшие 16 бит / Результат сдвиговой операции (SHL или SHR)
6     | MUL\_RESULT\_HI | Результат целочисленного умножения, старшие 16 бит

Специальные регистры, доступные для записи

Номер | Название      | Описание
----- | --------      | --------
0     | OUT\_LEDS     | Младшие 4 бита управляются состоянием светодиодов на плате (только в PU0)
1     | MEM\_ADDR\_LO | Младшие 16 бит адреса для операции с оперативной памятью или перехода (только в PU0)
2     | MEM\_ADDR\_HI | Старшие 16 бит адреса для операции с оперативной памятью или перехода (только в PU0)

### Регистр состояния IN\_FLAGS

Формат (по битам, от старших к младшим): 0000 0000 CVZN mbPP

-   PP — номер текущего PU
-   m — 1 если в данный момент в фоне выполняется операция с оперативной памятью
-   b — 1 если нажата кнопка на плате
-   С — Carry flag, 1 если был перенос из старшего разряда
-   V — Overflow flag, 1 если было знаковое переполнение
-   Z — Zero flag, 1 если получился ноль
-   N — Negative flag, старший разряд результата (1 если
    результат отрицателен)

Флаги меняются, только если у команды был суффикс **S**, или это команда
TST или CMP.

Добавляемые к командам суффиксы
-------------------------------

Суффиксы соответствуют архитектуре ARM.\
Суффикс **S** означает, что команда долна менять флаги. Может
присутствовать только у арифметических команд (кроме TST, CMP, SHL, SHR,
MUL) и команд IN, OUT. Ставится после суффикса условного выполнения (при
его наличии).

#### Суффиксы условного выполнения

Могут добавлены к любой команде кроме NOP, IN, OUT. Команда будет
выполнена только при соответствующем условию значении флагов.

```
  ---------------------------------------------------------------------------
  Code               Suffix             Flags condition    Description
  ------------------ ------------------ ------------------ ------------------
  0000               AL                 Any                Always. This
                                                           suffix is normally
                                                           omitted.

  0001               EQ                 Z set              Equal

  0010               NE                 Z clear            Not equal

  0011               CS                 C set              Higher or same
                                                           (unsigned >= )

  0100               CC                 C clear            Lower (unsigned < )

  0101               MI                 N set              Negative

  0110               PL                 N clear            Positive or zero

  0111               VS                 V set              Overflow

  1000               VC                 V clear            No overflow

  1001               HI                 C set and Z clear  Higher (unsigned > )

  1010               LS                 C clear or Z set   Lower or same
                                                           (unsigned <=)

  1011               GE                 N and V the same   Signed >=

  1100               LT                 N and V differ     Signed <

  1101               GT                 Z clear, N and V   Signed >
                                        the same           

  1110               LE                 Z set or (N and V  Signed <=
                                        differ)            

  1111                                                     reserved
  ---------------------------------------------------------------------------
```

Форматы команд
--------------

Все команды занимают 32 бита (2 машинных слова) и выполняются за 1
такт.  
Общий формат команды (по битам):

    СССС oooo o--- ---- ---- ---- ----

-   CCCC (4 бита) — условие (см. выше суффиксы условного выполнения)
-   ooooo (5 битов) — опкод команды

Назначение остальных битов зависит от опкода.  
Замечания:

-   Каждая команда выполняется на всех PU одновременно. Если нужно
    выполнить только на одном - это можно сделать с помощью условного
    выполнения (взяв номер PU из IN\_FLAGS). Условный переход здесь не
    поможет, так как счетчик команд общий для всех и управляется только
    из PU0.
-   Если в PU0 был изменен один из общих регистров R8-R15, то в PU1-PU3
    новое значение станет доступно только через 2 такта

### NOP

Машинный код 0x00000000. Не делает ничего. Используется для задержки
между другими командами.

### Arithmetic commands

Формат:

    CCCC oooo os11 aaaa bbbb rrrr i0tf 0000

-   s — 1 - менять флаги, 0 - не менять флаги
-   aaaa — номер регистра общего назначения (при t=0) или спец. регистра (при t=1)
-   bbbb — номер регистра общего назначения
-   rrrr — номер регистра общего назначения (при f=0) или спец. регистра (при f=1)
-   i — побитовое инвертирование последнего операнда

*Замечание: если на предыдущем такте (в предыдущей команде) менялось
значение регистра rrrr, то будет использовано старое значение.*  
Примеры:

```
ADD r1, r2, r3         // r1 = r2 + r3
ADD r1, r2, NOT r3     // r1 = r2 + ~r3
ADDS r1, r2, r3        // выполнить сложение и изменить флаги
ADDEQ r1, r2, r3       // выполнить сложение, если Zero flag установлен в 1
ADDEQS r1, r2, r3      // выполнить сложение и изменить флаги, если Zero flag установлен в 1
ADDEQ r1, r2, NOT SHIFT_RESULT       // r1 = r2 + ~SHIFT_RESULT, если Zero flag установлен в 1

32 битное сложение ( MEM_RESULT_HI:MEM_RESULT_LO = r3:r4 + r5:r6 ):
ADD MEM_RESULT_LO, r4, r6
# если сюда вставить любую команду (даже NOP), то перенос из LO в HI не сработает
ADC MEM_RESULT_HI, r3, r5
```

Формат:

    CCCC oooo os10 aaaa bbbb iSpc cccc cccc

-   s — 1 - менять флаги, 0 - не менять флаги
-   aaaa — номер регистра общего назначения (в примере - r1)
-   bbbb (при p=0) — номер регистра общего назначения (в примере - r2)
-   bbbb (при p=1) — номер спец. регистра для чтения (в примере -
    IN\_FLAGS)
-   ccccccccc (9 битов) — константа
-   S — сдвиг константы на 7 битов влево
-   i — дополнение константы 0 (при i=0) или 1 при (i=1)

Пример:
```
    ADDS r1, r2, 1              // r1 = r2 + 1 ; и изменение флагов
    AND r1, IN_FLAGS, 0x0f00    // r1 = IN_FLAGS & 0xf00
    Замечание: константа не может быть любой.
    Например можно использовать 65535 (c=511, i=1, S=0) и 1536 (c=12, i=0, S=1), но нельзя 1537.
```

Формат:

    CCCC oooo os01 aaaa bbbb rrrr Gccc cccc

-   s — 1 - менять флаги, 0 - не менять флаги
-   aaaa — номер регистра общего назначения (в примере - r1)
-   bbbb — номер регистра общего назначения (в примере - r2)
-   rrrr — номер регистра общего назначения для адресации в кэше (в
    примере - r3)
-   ccccccc (7 битов) — смещение от 0 до 127
-   G — 0 - все PU загружают одну ячейку, 1 - загружаются 4 соседних
    ячейки (ALL)

Пример:
```
ADDEQ r1, r2, [r3 + 10]       // r1 = r2 + cache[r3 + 10], если Zero flag установлен в 1
ADD r1, r2, [ALL r3 + 10]     // r1 = r2 + cache[r3 + 10]
Замечания:
1) Если указано ключевое слово ALL, то адрес (в этом примере r3 + 10, r3 берется из PU0) должен быть кратен четырем.
    Будут считаны 4 последовательных ячейки, каждая в свой PU.
2) Если адресный регистр (r3) менялся в последних двух командах, то будет использовано его старое значение.
3) Если значение в кэше было изменено в последних 3-х командах, то будет получено старое значение.
Эти замечания актуальны для любых команд, работающих с кэшем.
```

Формат:

    CCCC oooo os00 aaaa bbbb rrrr Gccc cccc

-   s — 1 - менять флаги, 0 - не менять флаги
-   aaaa — номер регистра общего назначения (в примере - r1)
-   bbbb — номер регистра общего назначения (в примере - r2)
-   rrrr — номер регистра общего назначения для адресации в кэше (в
    примере - r3)
-   ccccccc (7 битов) — смещение от 0 до 127
-   G — 0 - только для PU0, 1 - для всех (ALL)

Пример:
```
ADD [r3 + 10], r2, r1         // cache[r3+10] = r2 + r1, только для PU0
ADDEQ [ALL r3 + 10], r2, r1   // cache[r3+10] = r2 + r1, для всех PU, у которых Zero flag установлен в 1
Замечания:
1) Если указано ключевое слово ALL, то адрес (в этом примере r3 + 10, r3 берется из PU0) должен быть кратен четырем.
    Будут записаны 4 последовательных ячейки.
2) Если адресный регистр (r3) менялся в последних двух командах, то будет использовано его старое значение.
3) Новое значение окажется в кэше только через 3 такта.
```

### CMP/TST

Формат параметров и формат машинной команды эквивалентен арифметическим
командам (см. выше).\
В ассемблерном представлении опускается первый параметр и не указывается
суффикс S. В машинной команде всегда aaaa = 0000, а s = 1.\
Примеры:
```
CMP r1, r2          // сравнить r1 с r2
CMPEQ r8, [r3+115]  // сравнить r8 с [r3+115], если предыдущее сравнение показало равенство
TST IN_FLAGS, 1 # проверить четность номера PU.
                # После этого ADDEQ выполнится только на PU0 и PU2, а ADDNE только на PU1 и PU3
```

### WMUL

Формат параметров и формат машинной команды эквивалентен остальным
арифметическим командам (см. выше).\
Значение aaaa в формате команды должно быть 2.
```
Команда "WMUL r1, r2" произведет следующее действие:
    MUL_RESULT_LO = HI(r1 * r2) + LO(r1 * MUL_RESULT_HI)
    MUL_RESULT_HI = HI(r1 * r2)
Умножение беззнаковое.
Новое значение MUL_RESULT_HI будет доступно через 2 такта.
Новое значение MUL_RESULT_LO будет доступно через 3 такта.
```

### SHL/SHR/MUL/SMUL

Формат параметров и формат машинной команды эквивалентен остальным
арифметическим командам (см. выше).\
Результат сохраняется в спец. регистры.

-   SHL/SHR — Результат доступен через такт. Запрещено инвертирование
    последнего операнда
-   MUL — Беззнаковое умножение. Результат доступен через 2 такта
-   SMUL — Умножение со знаком. Результат доступен через 2 такта

В ассемблерном представлении опускается первый параметр и запрещен
суффикс S. Команды MUL, SMUL и WMUL имеют одинаковый опкод. Различие
между ними происходит по битам aaaa. Для SMUL aaaa=1, для WMUL aaaa=2, в
остальных случаях aaaa=0. Бит s всегда равен нулю.\
Пример:
```
MUL r1, r2            // MUL_RESULT_HI:MUL_RESULT_LO = r1 * r2
NOP
NOP                   // ждем результата
SHR MUL_RESULT_HI, 8  // сдвигаем старшие 16 бит на 8 вправо
NOP                   // ждем результата
SHL SHIFT_RESULT, 4   // сдвигаем на 4 влево
```

*Замечание: MUL\_RESULT\_LO и SHIFT\_RESULT — разные названия одного и
того же регистра.*

### MOV

Формат параметров и формат машинной команды эквивалентен арифметическим
командам (см. выше).\
В ассемблерной записи второй параметр отсутствует. Значение bbbb должно
быть или 0 или 1. Если bbbb = 1, то aaaa - не номер регистра общего
назначения, а номер спец. регистра.\
Примеры:
```
    Формат команды: CCCC oooo os00 aaaa 000p rrrr Gccc cccc
MOVS [r1 + 5], r4
MOV [ALL r1 + 5], r4
MOV [r1 + 5], IN_FLAGS

    Формат команды: CCCC oooo os01 aaaa 000p rrrr 1ccc cccc
MOV r3, [r2+1]
MOV OUT_LEDS, [r2]

    Формат команды: CCCC oooo os10 aaaa 000p is0c cccc cccc
MOV OUT_LEDS, 7

    Формат команды: CCCC oooo os11 aaaa 000p rrrr i000 0000
MOV MEM_ADDR_HI, r1

    Формат команды: CCCC oooo os11 aaaa 000p rrrr i001 0000
MOV MEM_ADDR_LO, NOT SHIFT_RESULT
MOV r2, MUL_RESULT_LO
```

### IN/OUT

Команды для работы с портами ввода-вывода. Порт имеет адрес от 0 до 15.
Считывание и запись выполняются по одному байту. Команды не могут
выполняться условно (код условия должен быть равен нулю). Опкод тот же,
что и у MOV, разные обозначения в ассемблере введены для удобства
использования. Если есть суффикс **S**, команда установит Negative flag
в 0 (если операция успешна) или в 1 (если нет данных для чтения, либо
переполнен буфер для записи).
```
    Формат команды: 0000 oooo os00 aaaa 0010 rrrr 0ccc cccc
    Действие: port(a) >> [r+c]
IN DEV_SDRAM, [r1+1]
INS DEV_SERIAL, [r1+2]

    Формат команды: 0000 oooo os01 aaaa 0011 rrrr 0ccc cccc
    Действие: port(a) << [r+c]
OUT DEV_SERIAL, [r2]

    Формат команды: 0000 oooo os10 aaaa 0011 0000 cccc cccc
    Действие: port(a) << c
OUT DEV_SERIAL, 'a'

    Формат команды: 0000 oooo os11 aaaa 0011 rrrr i000 0000
    Действие: port(a) << [~]r
OUTS DEV_SERIAL, r1
OUT DEV_SERIAL, NOT r2

    Формат команды: 0000 oooo os11 aaaa 0011 rrrr i001 0000
    Действие: port(a) << [~]special(r)
OUT DEV_SERIAL, SHIFT_RESULT

    Формат команды: 0000 oooo os11 aaaa 0010 rrrr i000 0000
    Действие: port(r) >> a
IN DEV_VGA, r1
```

##### \[0\] Serial port (константа DEV\_SERIAL)

Взаимодействие с компьютером через последовательный порт (в Marsohod2
используется виртуальный последовательный порт при подключении платы по
usb). Частота передачи - 6MHz (скорость порядка 500КБ/с). Для настройки
соединения со стороны компьютера (решение для linux) нужно выполнить
следующие команды:
```bash
stty -F /dev/serial/by-id/usb-FTDI_Dual_RS232-HS-if01-port0 9600 -icrnl -ixon -ixoff -opost -isig -icanon -echo cstopb
setserial /dev/serial/by-id/usb-FTDI_Dual_RS232-HS-if01-port0 spd_cust
setserial /dev/serial/by-id/usb-FTDI_Dual_RS232-HS-if01-port0 divisor 10
stty -F /dev/serial/by-id/usb-FTDI_Dual_RS232-HS-if01-port0 38400 2> /dev/null
```

Буферы на прием и на передачу имеют размер по 8 байт каждый.

##### \[1\] Sdram stats (константа DEV\_SDRAM)

Статистика загруженности канала доступа к памяти. Доступно только для
чтения. При чтении по очереди выдаются два байта: процент полезной
нагрузки (когда передавались данные) и процент ожидания запроса (когда
память готова к работе, но запросы отсутствуют). Оба числа принимают
значения от 0 (0%) до 255 (100%).

##### \[2\] VGA control (константа DEV\_VGA)

Управление контроллером VGA. Разрешение 640x480, 60 кадров в секунду.
Данные для вывода на экран берутся напрямую из оперативной памяти. Порт
используется для настройки режима (графический, текстовый или
комбинированный) и адреса видеопамяти. Если включен и текст и графика,
текст отображается поверх графического изображения\
При каждом чтении выдается один байт — номер текущего кадра по модулю
256.\
Настраиваемые параметры VGA занимают 6 байт. При записи следует
передавать их в порядке возрастания номера (от 0-го к 5-му). Если все 6
байтов уже записаны, следующий байт будет опять записан в 0-й байт
параметров.\
Назначение параметров:

                Байты B0, B1 задают адрес текстового буфера. Адрес выравнивается по 256 ячеек: addr = (B1<<16)|(B0<<8)
                    Каждый символ задается двумя байтами (одна ячейка) в формате:
                    rrrgggbb сссссссс (по битам)
                        c - ascii код
                        r - цвет символа. красная составляющая (от 0 до 7)
                        g - цвет символа. зеленая составляющая (от 0 до 7)
                        b - цвет символа. синяя составляющая (от 0 до 3)
                    Символы задаются подряд, слева направо
                    Строки задаются сверху вниз. Строки должны быть выровнены по 128 ячеек.
                Байт B2: Флаги текстового режима. Если старший бит установлен, текст выключен. Другие биты не используются.
                Байты B3, B4 (если графика включена): адрес графического буфера. Выравнивается по 256 ячеек: addr = (B4<<16)|(B3<<8)
                    Каждый пиксел задается двумя байтами (одна ячейка) в формате:
                    rrrrrggg gggbbbbb (по битам)
                        r - цвет пиксела. красная составляющая (от 0 до 7)
                        g - цвет пиксела. зеленая составляющая (от 0 до 7)
                        b - цвет пиксела. синяя составляющая (от 0 до 3)
                    Если графика выключена, то байты B3,B4 задают цвет фона (в том же формате, B3 -- младший, B4 -- старший).
                Байт B5: Флаги графического режима. Если старший бит установлен, графика выключена. Другие биты не используются.
            

##### \[3\] Sound control (константа DEV\_SOUND, не реализовано)

##### \[4,5\] PS/2 (константы DEV\_PS2\_0 и DEV\_PS2\_1)

Протокол PS/2. Два порта. Буфер приема имеет размер 8 байт. Буфер
передачи отсутствует. После отправки каждого байта необходимо дождаться
ответа от устройства прежде чем отправлять следующий байт.

##### \[6\] USB (константа DEV\_USB)

Реализован хост-контроллер USB1.1. Поддерживаются и low-speed, и
full-speed устройства.

Для передачи пакета нужно записать в порт размер пакета, учитывая PID и
не учитывая CRC16 (т.е. размер может быть от 1 до 65), после чего (если
не был установлен флаг **Z**, сигнализирующий о занятости порта)
передать указанное количество байт. Промежутки между отправкой отдельных
байтов должны составлять не более 8-и тактов. В процессе отправки тела
пакета допустимо не проверять флаг **N**. Контрольные суммы CRC16 и CRC5
генерируются автоматически. SOF пакеты генерируются автоматически.
Повтор отправки при отсутствии подтвержения (ACK) аппаратно не
реализован. Передача нуля вместо размера пакета вызовет перезагрузку
устройства (SE0 в течении 17мс) или установку флага **N**, если
устройство не подключено.

При чтении из порта будет получен размер пакета (если в буфере приема
есть новый пакет), либо будет установлен флаг **N**, если новый пакет
отсутствует. Если пакет был принят с ошибками (некорректный PID или
CRC), то старший бит размера пакета будет установлен в 1. То есть
считанный из порта байт окажется больше 128-и. После получения размера
пакета нужно считать соответствующее количество байт. В процессе
считывания тела пакета допустимо не проверять флаг **N**. CRC суммы
проверяются автоматически и исключаются из пакета. ACK подтверждение для
полученных пакетов данных с корректной контрольной суммой высылается
автоматически.

Для приема и передачи используется один и тот же буфер, поэтому при
передаче пакета из буфера удаляется последний считанный пакет.

##### \[7\] reserved

### CMOV

Загрузка 2-байтовой константы в регистр или спец. регистр.

                Формат команды: CCCC oooo o000 aaaa cccc cccc cccc cccc
            Константа 'с' загружается в регистр общего назначения с номером 'а'
            Пример: CMOV r1, 0x1234
                Формат команды: CCCC oooo o001 aaaa cccc cccc cccc cccc
            Константа 'с' загружается в спец. регистр для записи с номером 'а'
            Пример: CMOV MEM_ADDR_LO, 0x1234
            

### CCMOV

Загрузка 2-х байтовой константы в кэш. Выполняется только в PU0.

            Формат команды: CCCC oooo ommm cccc cccc rrrr cccc cccc
            Действие: cache[r+m] = c
                r - адресный регистр
                m - смещение от 0 до 7
                с - константа
            Пример: CCMOV [r15 + 2], 3600
            

### J/CALL/RET

Каждая из команд перехода может иметь суффикс условного выполнения.
После каждого перехода (даже безусловного) следующие 4 команды
выполняются со старой позиции (сброс конвеера отключен для увеличения
производительности).

                Формат команды: CCCC oooo o000 0000 0000 0000 0000 0000
                Действие: ip = MEM_ADDR -- переход на адрес из спец. регистра MEM_ADDR_HI:MEM_ADDR_LO
                Синтаксис в ассемблере: RET
                
                Формат команды: CCCC oooo o01c cccc cccc cccc cccc cccc
                Действие: ip += (с+4) -- относительный переход по смещению
                Синтаксис в ассемблере: J метка
                
                Формат команды: CCCC oooo o11c cccc cccc cccc cccc cccc
                Действие: MEM_ADDR = ip+5 ; ip += (c+4) -- сохранение текущего адреса в MEM_ADDR_HI:MEM_ADDR_LO и переход по смещению
                Синтаксис в ассемблере: CALL метка

                /* Пример простой функции (возведение r0 в квадрат) */
    func1:      RET // Сразу выполняем команду возврата (адрес записан в MEM_ADDR). Еще 4 команды выполнятся с этой позиции.
                    MUL r0, r0 // возводим в квадрат
                    NOP
                    NOP // ждем, пока результат запишется в MUL_RESULT
                    MOV r0, MUL_RESULT_LO // копируем произведение в r0

                /* Более сложная функция с передачей параметра по ссылке через стек и сохранением адреса в стеке. Для указателя стека используется r15. */
    func2:      SUB r15, r15, 2 // выделяем место в стеке под адрес
                MOV r0, [r15] // достаем параметр из стека (используется старое значение r15)
                NOP // ждем, пока новое значение r15 можно будет использовать в адресе
                MOV [r15], MEM_ADDR_LO // сохраняем адрес возврата в стек
                MOV [r15+1], MEM_ADDR_HI
                CALL func1 // вызываем вложенную функцию
                    NOP
                    NOP
                    NOP // ожидание перехода (вместо этого можно использовать DCALL)
                    NOP
                MOV MEM_ADDR_LO, [r15] // загружаем адрес из стека
                MOV MEM_ADDR_HI, [r15+1]
                MOV [r15+2], r0 // сохраняем ответ в стек на место параметра
                RET // возврат из фунции
                    ADD r15, 2 // возвращаем указатель стека на место
                    NOP
                    NOP // ожидание перехода
                    NOP

### DJ/DCALL/DRET

Эти команды работают аналогично J, CALL и RET, но вызывают сброс буфера
команд. Формат машинной команды также аналогичен, за исключением опкода.
Это единственные команды, выполнение которых занимает более 1-го такта
(а именно — 5 тактов).

                Формат команды: CCCC oooo o000 0000 0000 0000 0000 0000
                Действие: ip = MEM_ADDR -- переход на адрес из спец. регистра MEM_ADDR_HI:MEM_ADDR_LO
                Синтаксис в ассемблере: DRET
                
                Формат команды: CCCC oooo o01c cccc cccc cccc cccc cccc
                Действие: ip += (с+1) -- относительный переход по смещению
                Синтаксис в ассемблере: DJ метка
                
                Формат команды: CCCC oooo o11c cccc cccc cccc cccc cccc
                Действие: MEM_ADDR = ip+1 ; ip += (c+1) -- сохранение текущего адреса в MEM_ADDR_HI:MEM_ADDR_LO и переход по смещению
                Синтаксис в ассемблере: DCALL метка
            
            Пример:
            команда DJ addr
            эквивалентна конструкции:
                J addr
                    NOP
                    NOP
                    NOP
                    NOP
            

### READ/WRITE

Пересылка блока данных между кэшем и оперативной памятью. Пересылка
выполняется в фоновом режиме. Если новая пересылка запущена до
завершение предыдущей, то предыдущая останавливается. Убедиться, что
предыдущая пересылка завершилась, можно по значению [флага
"m"](#in_flags).\
*Замечание: В следующей команде после старта операции флаг "m" еще не
успеет измениться в 1.*\
Пересылка запускается только из PU0. Начальное значение адреса в
оперативной памяти берется из спец. регистров
MEM\_ADDR\_HI:MEM\_ADDR\_LO.

            Формат команды: CCCC oooo ow01 0000 bbbb rrrr 0ccc cccc
                w -- 1 - запись (команда WRITE), 0 - чтение (команда READ)
                bbbb -- начальный адрес в кэше
                rrrr и ссссссс -- адресный регистр и смещение, по которому в кэше хранится количество ячеек в блоке
            Пример: READ r8, [r1+2] // Взять [r1+2] ячеек из оперативной памяти, начиная с адреса MEM_ADDR_HI:MEM_ADDR_LO и записать начиная с адреса r8 в кэше
            
            Формат команды: CCCC oooo ow10 0000 bbbb iS0c cccc cccc
                w -- 1 - запись (команда WRITE), 0 - чтение (команда READ)
                bbbb -- начальный адрес в кэше
                ccссссссс -- константа (размер блока)
                S -- сдвиг константы на 7 битов влево
                i -- дополнение константы нулями (i=0) или единицами (i=1)
            Пример:
                CMOV r8, 0
                WRITE r8, 16384 // Всё содержимое кэша записать в оперативную память, начиная с адреса MEM_ADDR_HI:MEM_ADDR_LO
            
            Формат команды: CCCC oooo ow11 0000 bbbb rrrr i00p 0000
                w -- 1 - запись (команда WRITE), 0 - чтение (команда READ)
                bbbb -- начальный адрес в кэше
                rrrr -- номер регистра (при p=0) или спец. регистра (при p=1) (размер блока)
                i -- побитовое инвертирование rrrr (при i=1)
            Примеры:
                READ r8, r1 // Взять r1 ячеек из оперативной памяти, начиная с адреса MEM_ADDR_HI:MEM_ADDR_LO и записать начиная с адреса r8 в кэше
                WRITE r8, MUL_RESULT_LO
                WRITE r8, NOT SHIFT_RESULT
            

# Синтаксис ассемблера

Комментарии задаются в стиле Си. До конца строки — "//", Несколько строк
— "/\* ... \*/".

### Константы

            1) Десятичные числа. Пример: -57
            2) Шеснадцатиричные числа. Пример: 0x120
            3) Символы. Пример: 'a'
            4) Для чисел, не помещающихся в два байта (одна ячейка):
                LO(65538)       - 2 (младшие два байта)
                HI(65538)       - 1 (старшие два байта)
                LO(1.0)         - 0x0000 (младшие два байта)
                HI(1.0)         - 0x3f80 (старшие два байта)
                Для float указание десятичной точки обязательно
            5) Цвет: RGB("R G B")
                R, G, B -- целые числа от 0 до 31
            Предопределенные константы:
            DEV_SERIAL = 0      - номер I/O порта Serial
            DEV_SDRAM = 1       - номер I/O порта для получения статистики использования sdram
            DEV_VGA = 2         - номер I/O порта контроллера VGA
            N_FLAG  = 16        - маска флага N в регистре IN_FLAGS
            Z_FLAG = 32         - маска флага Z в регистре IN_FLAGS
            V_FLAG = 64         - маска флага V в регистре IN_FLAGS
            C_FLAG = 128        - маска флага C в регистре IN_FLAGS
            SOFTKEY_FLAG = 4    - маска флага b (нажатие кнопки на плате) в регистре IN_FLAGS
            MEM_FLAG = 8        - маска флага m (выполнение операции с sdram в данный момент) в регистре IN_FLAGS
            

Константные выражения могут использовать операции +, -, \*, /, %, &, |,
\^, \~, &lt;&lt;, &gt;&gt; и скобки.

### Метки и адреса

Метки указываются в начале строки. После имени метки ставится двоеточие.
Все вхождения метки в программе будут заменены на её значение.\

-   .code maddr raddr — сегмент команд. maddr -- точка отсчета для
    меток, raddr -- физический адрес сегмента в выходном файле. Сегменты
    должны быть описаны в том же порядке, в котором будут находиться в
    выходном файле.
-   .data maddr raddr — работает в точности также, как и .code;
    рекомендуется использовать для сегментов данных.
-   .virtual maddr — сегмент неинициализированных данных.
-   .words ЧИСЛО — неинициализированные данные (увеличение смещения на
    указанное число)
-   .ascii "STRING" — строковая константа; два символа в слове; при
    нечетном количестве символов дополняется нулем; заканчивается
    нулевым словом
-   .const ЧИСЛО, ЧИСЛО, ЧИСЛО, ... — константы

Пример:
```
        .code 0x0 0x0
                MOV r0, 0
                MOV r1, 5
                MOV r2, 7
                CMOV [r0 + var_a], r1
                CMOV [r0 + var_b], r2
                .const 0x0000, 0x0000 // Эквивалентно команде NOP
        .offset 0x0 0x100
        var_a:      .words 1
        var_b:      .words 1
```

### Препроцессор

Используется препроцессор Си. Комментарии указываются в стиле Си.\
Дополнительно добавлены макросы в следующем формате:
```
            .macro some_name // объявление макроса some_name без параметров
    $(m)_loop:  J $(m)_loop  // бесконечный цикл
                    NOP
                    NOP
                    NOP
                    NOP
            .endmacro
            .macro swap p1, p2 // макрос с параметрами
                MOV r0, p2
                MOV p2, p1
                MOV p1, r0
            .endmacro
            some_name // вызов макроса без параметров
            swap r5, r7 // вызов макроса с параметрами
```

Вместо `$(m)` при подстановке макроса будет вставлен уникальный номер.
Таким образом метка, начинающаяся с `$(m)`, будет уникальна даже при
использовании одного макроса несколько раз.

# Загрузчик

После включения питания загрузчик пытается считать программу через
последовательный порт или через USB. Считанные данные загружаются в
оперативную память, начиная с адреса 0x100000 (т.е. с 3-го мегабайта).
Если проверка контрольной суммы успешна, выполняется переход на адрес
0x100000. Загрузчик хранится в ПЗУ на 4кб (512 команд). Ему
соответствуют адреса 0x0 - 0x400, однако при чтении из оперативной
памяти командами READ и WRITE ПЗУ не задействуется. Т.е. тот же диапазон
адресов 0x0 - 0x400 можно использовать для хранения данных. Но при
передаче управления на адрес из этого диапазона, будет выполнен код из
ПЗУ. В ПЗУ, помимо загрузчика, содержатся следующие функции: отправка
USB Request, деление с остатком, перевод числа в строку и функция
форматированного вывода. Их описания и адреса находятся в файле
include/std.H.

#### Загрузка через последовательный порт

Перед загрузкой по последовательному порту к программе нужно добавить
заголовок, содержащий размер и контрольную сумму. Заголовок добавляется
скриптом pack.py. Затем нужно настроить baud\_rate виртуального
последовательного порта на 6MHz (в линуксе делается скриптом
prepare\_port.sh) и переслать файл в плату марсоход2.

#### Загрузка через USB

Работает не для всех флешек. Откомпилированную программу нужно дополнить
до размера 2МБ и дописать в конец контрольную сумму (делается скриптом
pack\_usb.py). Затем записать на флешку, начиная с блока 2048 (т.е.
пропустить 1 мегабайт от начала флешки). Это удобно сделать, если
настроить таблицу разделов на флешке, чтобы один из разделов начинался с
этого адреса.

# Некоторые особенности

-   После перехода командами J, CALL или RET выполняется 4 команды со
    старой позиции. Если такое поведение нежелательно, используйте
    команды DJ, DCALL, DRET.
-   Если регистр менялся в последних двух командах, то при использовании
    в адресе будет взято старое значение
-   Если значение в кэше было изменено в последних 3-х командах, то при
    чтении будет получено старое значение
-   ADC, RSC, SBC используют перенос предыдущей команды, даже если эта
    команда не сохраняла флаги
-   Между обращениями к разным устройствам ввода-вывода должно пройти не
    менее 3-х тактов
-   IN и OUT не могут иметь суффикс условного выполнения
-   Если в PU0 был изменен один из общих регистров R8-R15, то в PU1-PU3
    новое значение станет доступно только через 2 такта.

                            Пример:
                            TST IN_FLAGS, 1
                            CMOVEQ r0, 1
                            CMOVNE r0, 2
                            MOV r8, r0
                            NOP
                            MOV r1, r8 // в PU0 и PU2 будет r1=1, в PU1 и PU3 -- r1=2
                            MOV r2, r8 // во всех PU   r2=1
                        

-   Команды SHL, SHR не меняют флаги и для них не работает
    инвертирование второго операнда. Результат доступен в спец. регистре
    через такт.
-   Команды MUL, SMUL не меняют флаги. Результат доступен в спец.
    регистрах через 2 такта.
-   Команда WMUL не меняет флаги. Результат доступен в спец. регистрах
    через 3 такта.
-   Изменение любого спец. регистра вступает в силу только через один
    такт (должна быть как минимум одна команда между изменением
    и использованием).
-   В следующем такте после операции READ или WRITE флаг "m",
    указывающий на выполняющуюся операцию с памятью, еще не установлен.
-   В арифметических командах если последний параметр — регистр,
    измененный в предыдущей команде, то будет использовано
    старое значение.

### Недоработки

1) Не реализована работа со звуком

2) Не реализован кэш команд. На данный момент кэш команд жестко привязан к адресам 0x100000-0x101000 оперативной памяти.
Т.е. любой исполняемый код (кроме кода загрузчика) должен лежать в этом кусочке оперативной памяти. Загрузчик размещает программу по адресу 0x100000 и передаёт туда управление.

3) Не реализованы команды LPU0-LPU3

Примеры программ
----------------

------------------------------------------------------------------------
```
    // timer.S
    // Меняет состояние светодиодов два раза в секунду
    .code 0x0
    l:          J l
                SHR IN_TIME_MS4, 11
                NOP
                MOV OUT_LEDS, SHIFT_RESULT
                NOP
```

------------------------------------------------------------------------
```
    // serial.S
    // Возвращает полученные через последовательный порт байты
    // Меняет состояние светодиодов при удержании кнопки на плате
    .code 0x0
                CMOV r0, SOFTKEY_FLAG
    l:          INS DEV_SERIAL, r1
                JMI l
                    TST r0, IN_FLAGS
                    CMOVEQ OUT_LEDS, 10
                    CMOVNE OUT_LEDS, 5
                    NOP
                OUT DEV_SERIAL, r1
                DJ l
```

------------------------------------------------------------------------
```
    // pu_sum.S
    // Считает сумму номеров всех PU и выводит на светодиоды
    .code 0x0
                MOV r15, 0
                NOP
                AND r0, IN_FLAGS, 3
                MOV [ALL r15], r0
                NOP
                NOP
                NOP
                ADD r1, r15, [r15]
                ADD r1, r1, [r15+1]
                ADD r1, r1, [r15+2]
                ADD r1, r1, [r15+3]
                MOV OUT_LEDS, r1
    end:        DJ end
```

------------------------------------------------------------------------
```
    // rhomb.S
    // Заполняет экран цветными ромбиками
    #define SCREEN_WIDTH 640
    #define SCREEN_HEIGHT 480
    #define X r0
    #define Y r14
    #define tmp r1
    #define mem_lo r12
    #define mem_hi r13
    #define COLOR r2
    #define SCREEN_WIDTH_S4 r11
    .code 0x0
                OUT DEV_VGA, 0
                OUT DEV_VGA, 0
                OUT DEV_VGA, 128
                OUT DEV_VGA, 0
                OUT DEV_VGA, 0
                OUT DEV_VGA, 0
                CMOV mem_lo, 0
                CMOV mem_hi, 0
                CMOV SCREEN_WIDTH_S4, SCREEN_WIDTH-4
                CMOV Y, 0
    loop_y:     AND X, IN_FLAGS, 3
    loop_x:     ADD tmp, X, Y
                TST tmp, 16
                CMOVEQ COLOR, 0
                CMOVNE COLOR, 0xf800
                SUB tmp, X, Y
                CMP X, SCREEN_WIDTH_S4
                JNE loop_x
                    TST tmp, 16
                    ORNE COLOR, COLOR, 0x1f
                    MOV [ALL X], COLOR
                    ADD X, X, 4
                ADD mem_lo, mem_lo, SCREEN_WIDTH
                ADC mem_hi, mem_hi, 0
                MOV MEM_ADDR_LO, mem_lo
                MOV MEM_ADDR_HI, mem_hi
                CMOV tmp, 0
                TST IN_FLAGS, MEM_FLAG
    wait_mem:   JNE wait_mem
                    WRITEEQ tmp, SCREEN_WIDTH
                    CMPEQ Y, SCREEN_HEIGHT-1
                    JMI loop_y
                    TST IN_FLAGS, MEM_FLAG
                    ADD Y, Y, 1
                    NOP
                    NOP
    end:        DJ end
```
